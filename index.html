<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Roadmap</title>
  <style>
    /* Remove margins and allow the canvas to fill the window */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
      background: #f0f0f0;
    }
    /* Sticky instructions at top left */
    #instructions {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 5px;
      font-family: sans-serif;
      z-index: 10;
      max-width: 300px;
      max-height: 400px;
      overflow-y: auto;
    }
    /* API settings and action overlay remain fixed */
    #api-settings, #action-overlay {
      position: absolute;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 5px;
      font-family: sans-serif;
      z-index: 10;
    }
    #api-settings {
      bottom: 10px;
      left: 10px;
    }
    #action-overlay {
      top: 10px;
      right: 10px;
    }
    /* Zoom controls positioned fixed in bottom right */
    #zoom-controls {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 5px;
      font-family: sans-serif;
      z-index: 10;
    }
  </style>
</head>
<body>
  <!-- Sticky Instructions on top left -->
  <div id="instructions">
    <button id="instructions-close-btn" style="float: right; font-size: 16px; line-height: 1; cursor: pointer;">Ã—</button>
    <p><strong>Instructions:</strong></p>
    <ul>
      <li>Click on a node to select it (orange outline appears).</li>
      <li>Drag a node to move it. Connected nodes will tug each other.</li>
      <li>Hold <code>Shift</code> and drag from one node to another to create an edge.</li>
      <li>Hold <code>Ctrl</code>/<code>Cmd</code> while dragging to reposition a node directly.</li>
      <li>Double-click a node or press <code>e</code> to edit its text inline.</li>
      <li>Press <code>d</code> to delete the selected node (and its edges).</li>
      <li>Use the <strong>Add Node</strong> button to create a new node at the view's center.</li>
      <li>Use the <strong>Delete Node</strong> button to remove the selected node.</li>
      <li>Use the <strong>Edit Node</strong> button to edit a node's text.</li>
      <li>Use the <strong>Connect Node</strong> button to start connecting nodes; use <strong>Cancel Connect</strong> to abort.</li>
      <li>Use the <strong>Export Mermaid</strong> button to download your graph as Mermaid code.</li>
      <li>Use the <strong>Generate Roadmap</strong> button to create a new roadmap (requires OpenAI API Key).</li>
      <li>Use the <strong>Clear Graph</strong> button to delete every node and connection (confirmation required).</li>
      <li>Scroll on the canvas to pan.</li>
      <li>Hold <code>Ctrl</code> and scroll to zoom in and out.</li>
    </ul>
  </div>

  <!-- Show Instructions Button (appears when instructions are closed) -->
  <button id="show-instructions-btn" style="position: fixed; top: 10px; left: 10px; z-index: 10; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 5px; padding: 5px; font-family: sans-serif; display: none;">Show Instructions</button>

  <!-- API Key Settings -->
  <div id="api-settings">
    <label for="openai-api-key">OpenAI API Key:</label>
    <input type="password" id="openai-api-key" placeholder="Enter API Key">
  </div>
  
  <!-- UI Overlay for actions -->
  <div id="action-overlay">
    <button id="add-node-btn">Add Node</button>
    <button id="delete-node-btn">Delete Node</button>
    <button id="edit-node-btn">Edit Node</button>
    <button id="connect-node-btn">Connect Node</button>
    <button id="cancel-connect-btn" style="display:none;">Cancel Connect</button>
    <button id="export-mermaid-btn">Export Mermaid</button>
    <button id="generate-roadmap-btn">Generate Roadmap</button>
    <button id="clear-graph-btn">Clear Graph</button>
  </div>
  
  <!-- Zoom Controls (fixed in bottom right) -->
  <div id="zoom-controls">
    <button id="zoom-in-btn">Zoom In</button>
    <button id="zoom-out-btn">Zoom Out</button>
    <button id="zoom-reset-btn">Reset</button>
    <span id="zoom-label">100%</span>
  </div>
  
  <canvas id="canvas"></canvas>
  <script>
    /* Set up canvas */
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    window.addEventListener("resize", () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });

    /* Global arrays and variables */
    const nodes = [];
    const edges = [];
    let draggedNode = null;
    let currentSelectedNode = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let isCreatingEdge = false;
    let edgeStart = null;
    let mouseX = 0;
    let mouseY = 0;
    // Global pan offsets (in screen coordinates) and zoom scale
    let panOffsetX = 0;
    let panOffsetY = 0;
    let scale = 1;


    const generatePromptMessage = (currentMermaid, userGoal) => `
I have the following current roadmap in mermaid format:
${currentMermaid}
My goal is: "${userGoal}"

Generate action plans for the roadmap to achieve the goal.
Each node should be completeable tasks that lead to the goal.

For example, if the goal is "I want to build a simple LLM application", the roadmap might be:

graph LR
    node0["Learn ChatGPT API"]
    node1["Learn prompt engineering"]
    node2["Send a request to the ChatGPT API"]
    node3["Simple CLI with Node.js"]
    node4["Learn RAG"]
    node5["Build a simple RAG application"]
    node6["Simple web app with Next.js"]
    node0 --> node1
    node0 --> node2
    node2 --> node3
    node3 --> node4
    node4 --> node5
    node4 --> node6

Generate around 5 nodes, more branching nodes are better.
Return only the mermaid graph code (starting with "graph LR").
      `.trim();

    /* Color definitions */
    const COLOR_SCHEME = {
      GRID: '#fff',
      EDGE: '#64748b',
      NODE: {
        FILL: '#0ea5e9',
        BORDER: '#0284c7',
        TEXT: '#ffffff',
        SELECTED: '#f97316'
      },
      PREVIEW: '#dc2626'
    };

    let inlineEditor = null;
    let uiConnectMode = false;

    /* Node and Edge classes */
    class Node {
      constructor(x, y) {
        this.x = x;         // world coordinate
        this.y = y;         // world coordinate
        this.oldx = x;
        this.oldy = y;
        this.radius = 50;
        this.isDragging = false;
        this.directDragging = false;
        this.text = "";
        this.selected = false;
      }
    }
    class Edge {
      constructor(nodeA, nodeB, length) {
        this.nodeA = nodeA;
        this.nodeB = nodeB;
        this.length = length;
      }
    }

    /* Helper functions */
    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    }
    // Converts view (screen) coordinates to world coordinates (taking pan and zoom into account)
    function viewToWorld(x, y) {
      return { x: (x - panOffsetX) / scale, y: (y - panOffsetY) / scale };
    }
    // Returns a node if the given screen (view) coordinate hits it
    function getNodeAtPosition(x, y) {
      const worldPos = viewToWorld(x, y);
      for (let i = nodes.length - 1; i >= 0; i--) {
        const node = nodes[i];
        const dx = node.x - worldPos.x;
        const dy = node.y - worldPos.y;
        if (Math.sqrt(dx * dx + dy * dy) < node.radius) {
          return node;
        }
      }
      return null;
    }
    function clearSelection() {
      if (currentSelectedNode) {
        currentSelectedNode.selected = false;
        currentSelectedNode = null;
      }
    }
    function addNode() {
      clearSelection();
      // Create node at center of view (in world coordinates)
      const worldCenter = viewToWorld(canvas.width / 2, canvas.height / 2);
      const newNode = new Node(worldCenter.x, worldCenter.y);
      nodes.push(newNode);
      currentSelectedNode = newNode;
      newNode.selected = true;
    }
    function deleteNode() {
      if (currentSelectedNode) {
        for (let i = edges.length - 1; i >= 0; i--) {
          if (edges[i].nodeA === currentSelectedNode || edges[i].nodeB === currentSelectedNode) {
            edges.splice(i, 1);
          }
        }
        const index = nodes.indexOf(currentSelectedNode);
        if (index > -1) nodes.splice(index, 1);
        currentSelectedNode = null;
      }
    }
    function editNode() {
      if (currentSelectedNode) {
        editNodeInline(currentSelectedNode);
      }
    }
    function startConnectMode() {
      if (currentSelectedNode) {
        edgeStart = currentSelectedNode;
        uiConnectMode = true;
        document.getElementById("cancel-connect-btn").style.display = "inline-block";
        document.getElementById("connect-node-btn").style.display = "none";
      } else {
        alert("Please select a node first to start connecting.");
      }
    }
    function cancelConnectMode() {
      uiConnectMode = false;
      edgeStart = null;
      document.getElementById("cancel-connect-btn").style.display = "none";
      document.getElementById("connect-node-btn").style.display = "inline-block";
    }

    /* Auto-saving (Mermaid string to localStorage) */
    function saveMermaidData() {
      let mermaidString = "graph LR\n";
      let nodeToId = new Map();
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        const id = "node" + i;
        nodeToId.set(node, id);
        const safeText = node.text.replace(/"/g, '\\"');
        mermaidString += `${id}["${safeText}" | ${node.x},${node.y}]\n`;
      }
      for (const edge of edges) {
        const idA = nodeToId.get(edge.nodeA);
        const idB = nodeToId.get(edge.nodeB);
        if (idA !== undefined && idB !== undefined) {
          mermaidString += `${idA} --> ${idB}\n`;
        }
      }
      localStorage.setItem("mermaidData", mermaidString);
    }
    function loadMermaidData() {
      const data = localStorage.getItem("mermaidData");
      if (!data) return;

      // Clear current nodes and edges.
      nodes.length = 0;
      edges.length = 0;
      
      const lines = data.split("\n");
      // Remove graph header if present.
      if (lines.length > 0 && lines[0].startsWith("graph")) {
        lines.shift();
      }
      
      const idToNode = {};
      // Regex for nodes with coordinates: node\d+["text" | x,y]
      const nodeRegexWithCoords = /^(node\d+)\s*\[\s*"([^"]+)"\s*\|\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)\s*\]\s*$/;
      // Regex for nodes without coordinates: node\d+["text"]
      const nodeRegexWithoutCoords = /^(node\d+)\s*\[\s*"([^"]+)"\s*\]\s*$/;
      // Regex for edges: node\d+ --> node\d+
      const edgeRegex = /^(node\d+)\s*-->\s*(node\d+)\s*$/;
      
      // Compute center of the current view in world coordinates.
      const centerWorld = viewToWorld(canvas.width / 2, canvas.height / 2);

      lines.forEach(rawLine => {
        const line = rawLine.trim();
        if (line === "") return;
        
        let match = nodeRegexWithCoords.exec(line);
        if (match) {
          // Format: nodeX["text" | x,y]
          const id = match[1];
          const text = match[2];
          const x = parseFloat(match[3]);
          const y = parseFloat(match[4]);
          const newNode = new Node(x, y);
          newNode.text = text;
          nodes.push(newNode);
          idToNode[id] = newNode;
        } else if ((match = nodeRegexWithoutCoords.exec(line))) {
          // Format: nodeX["text"]
          // Place the node around the current view center with a random offset.
          const id = match[1];
          const text = match[2];
          const offsetX = (Math.random() - 0.5) * 300 + 200; // between -150 and 150
          const offsetY = (Math.random() - 0.5) * 200 + 100; // between -100 and 100
          const x = centerWorld.x + offsetX;
          const y = centerWorld.y + offsetY;
          const newNode = new Node(x, y);
          newNode.text = text;
          nodes.push(newNode);
          idToNode[id] = newNode;
        } else if ((match = edgeRegex.exec(line))) {
          // Format: nodeX --> nodeY
          const sourceId = match[1];
          const targetId = match[2];
          const sourceNode = idToNode[sourceId];
          const targetNode = idToNode[targetId];
          if (sourceNode && targetNode) {
            const dx = targetNode.x - sourceNode.x;
            const dy = targetNode.y - sourceNode.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            edges.push(new Edge(sourceNode, targetNode, length));
          }
        }
      });
    }

    /* Word wrapping helpers */
    function wrapText(ctx, text, maxWidth, fontSize) {
      ctx.font = fontSize + "px sans-serif";
      const words = text.split(' ');
      const lines = [];
      let currentLine = words[0] || "";
      for (let i = 1; i < words.length; i++) {
        const word = words[i];
        const testLine = currentLine + " " + word;
        const metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && currentLine !== "") {
          lines.push(currentLine);
          currentLine = word;
        } else {
          currentLine = testLine;
        }
      }
      lines.push(currentLine);
      return lines;
    }
    function wrapAndAdjustText(ctx, text, maxWidth, baseFontSize) {
      let fontSize = baseFontSize;
      let lines = wrapText(ctx, text, maxWidth, fontSize);
      let longest = 0;
      for (const line of lines) {
        const lineWidth = ctx.measureText(line).width;
        if (lineWidth > longest) longest = lineWidth;
      }
      if (longest > maxWidth) {
        fontSize = fontSize * (maxWidth / longest);
        lines = wrapText(ctx, text, maxWidth, fontSize);
      }
      return { lines, fontSize };
    }

    /* Inline editing of node text */
    function editNodeInline(node) {
      if (inlineEditor) return;
      const canvasRect = canvas.getBoundingClientRect();
      const input = document.createElement("input");
      input.type = "text";
      input.value = node.text;
      input.style.position = "absolute";
      input.style.width = "120px";
      input.style.fontSize = "16px";
      input.style.padding = "2px";
      input.style.border = "1px solid #ccc";
      input.style.zIndex = "100";
      // Position input relative to the canvas by converting node's world position to view (screen) position.
      input.style.left = `${canvasRect.left + (node.x * scale + panOffsetX) - 60}px`;
      input.style.top = `${canvasRect.top + (node.y * scale + panOffsetY) - 12}px`;
      inlineEditor = input;
      document.body.appendChild(input);
      input.focus();
      input.select();
      function finalizeEdit() {
        node.text = input.value;
        inlineEditor.remove();
        inlineEditor = null;
      }
      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") finalizeEdit();
        else if (e.key === "Escape") { inlineEditor.remove(); inlineEditor = null; }
      });
      input.addEventListener("blur", () => {
        if (inlineEditor) finalizeEdit();
      });
    }

    /* Mouse events */
    canvas.addEventListener("mousedown", (e) => {
      const pos = getMousePos(e);
      mouseX = pos.x;
      mouseY = pos.y;
      
      if (uiConnectMode) {
        const targetNode = getNodeAtPosition(pos.x, pos.y);
        if (targetNode && targetNode !== edgeStart) {
          const dx = targetNode.x - edgeStart.x;
          const dy = targetNode.y - edgeStart.y;
          const length = Math.sqrt(dx * dx + dy * dy);
          edges.push(new Edge(edgeStart, targetNode, length));
        }
        uiConnectMode = false;
        edgeStart = null;
        document.getElementById("cancel-connect-btn").style.display = "none";
        document.getElementById("connect-node-btn").style.display = "inline-block";
        return;
      }
      
      const node = getNodeAtPosition(pos.x, pos.y);
      if (node) {
        if (currentSelectedNode !== node) {
          clearSelection();
          currentSelectedNode = node;
          node.selected = true;
        }
        if (e.shiftKey) {
          isCreatingEdge = true;
          edgeStart = node;
        } else if (e.metaKey || e.ctrlKey) {
          draggedNode = node;
          node.isDragging = true;
          node.directDragging = true;
          let worldPos = viewToWorld(pos.x, pos.y);
          dragOffsetX = worldPos.x - node.x;
          dragOffsetY = worldPos.y - node.y;
        } else {
          draggedNode = node;
          node.isDragging = true;
          let worldPos = viewToWorld(pos.x, pos.y);
          dragOffsetX = worldPos.x - node.x;
          dragOffsetY = worldPos.y - node.y;
        }
      }
      // If clicked on empty space, do nothing (you must use the "Add Node" button)
    });
    canvas.addEventListener("mousemove", (e) => {
      const pos = getMousePos(e);
      mouseX = pos.x;
      mouseY = pos.y;
      if (draggedNode && draggedNode.isDragging) {
        const worldPos = viewToWorld(pos.x, pos.y);
        draggedNode.x = worldPos.x - dragOffsetX;
        draggedNode.y = worldPos.y - dragOffsetY;
      }
    });
    canvas.addEventListener("mouseup", (e) => {
      if (draggedNode) {
        if (draggedNode.directDragging) {
          for (let i = 0; i < edges.length; i++) {
            const edge = edges[i];
            if (edge.nodeA === draggedNode || edge.nodeB === draggedNode) {
              const dx = edge.nodeB.x - edge.nodeA.x;
              const dy = edge.nodeB.y - edge.nodeA.y;
              edge.length = Math.sqrt(dx * dx + dy * dy);
            }
          }
          draggedNode.directDragging = false;
        }
        draggedNode.isDragging = false;
        draggedNode = null;
      }
      if (isCreatingEdge) {
        const pos = getMousePos(e);
        const targetNode = getNodeAtPosition(pos.x, pos.y);
        if (targetNode && targetNode !== edgeStart) {
          const dx = targetNode.x - edgeStart.x;
          const dy = targetNode.y - edgeStart.y;
          const length = Math.sqrt(dx * dx + dy * dy);
          edges.push(new Edge(edgeStart, targetNode, length));
        }
        isCreatingEdge = false;
        edgeStart = null;
      }
    });

    /* Override scroll (wheel) events to implement panning and zooming.
       Hold the Ctrl key to zoom; otherwise, the wheel pans the view. */
    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      // If Ctrl is pressed, zoom; else, pan.
      if (e.ctrlKey) {
        const zoomSensitivity = 0.001;
        const factor = 1 - e.deltaY * zoomSensitivity;
        const mousePos = getMousePos(e);
        // Get the current world coordinates under the cursor.
        const worldPos = { 
          x: (mousePos.x - panOffsetX) / scale, 
          y: (mousePos.y - panOffsetY) / scale 
        };
        const newScale = scale * factor;
        // Adjust panOffset so that the world point under the mouse remains stationary.
        panOffsetX = mousePos.x - worldPos.x * newScale;
        panOffsetY = mousePos.y - worldPos.y * newScale;
        scale = newScale;
        updateZoomLabel();
      } else {
        panOffsetX -= e.deltaX;
        panOffsetY -= e.deltaY;
      }
    }, { passive: false });

    /* Physics update (using Verlet integration) */
    const damping = 0.8;
    const constraintIterations = 20;
    function update() {
      for (const node of nodes) {
        if (!node.isDragging) {
          const vx = (node.x - node.oldx) * damping;
          const vy = (node.y - node.oldy) * damping;
          node.oldx = node.x;
          node.oldy = node.y;
          node.x += vx;
          node.y += vy;
        } else {
          node.oldx = node.x;
          node.oldy = node.y;
        }
      }
      for (let i = 0; i < constraintIterations; i++) {
        for (const edge of edges) {
          const dx = edge.nodeB.x - edge.nodeA.x;
          const dy = edge.nodeB.y - edge.nodeA.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist === 0) continue;
          if (edge.nodeA.directDragging || edge.nodeB.directDragging) {
            edge.length = dist;
            continue;
          }
          const diff = (dist - edge.length) / dist;
          const offsetX = dx * 0.5 * diff;
          const offsetY = dy * 0.5 * diff;
          if (!edge.nodeA.isDragging) {
            edge.nodeA.x += offsetX;
            edge.nodeA.y += offsetY;
          }
          if (!edge.nodeB.isDragging) {
            edge.nodeB.x -= offsetX;
            edge.nodeB.y -= offsetY;
          }
        }
      }
    }

    /* Draw the scene with pan and zoom transforms */
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      // Apply pan and zoom to the entire scene.
      ctx.translate(panOffsetX, panOffsetY);
      ctx.scale(scale, scale);
      
      /* Draw grid in world coordinates */
      const gridSize = 20;
      const dotSize = 2;
      ctx.fillStyle = COLOR_SCHEME.GRID;
      // Compute visible world bounds:
      const worldLeftVisible   = (-panOffsetX) / scale;
      const worldTopVisible    = (-panOffsetY) / scale;
      const worldRightVisible  = (canvas.width - panOffsetX) / scale;
      const worldBottomVisible = (canvas.height - panOffsetY) / scale;
      for (let x = Math.floor(worldLeftVisible / gridSize) * gridSize; x < worldRightVisible; x += gridSize) {
        for (let y = Math.floor(worldTopVisible / gridSize) * gridSize; y < worldBottomVisible; y += gridSize) {
          ctx.beginPath();
          // Use dotSize divided by scale so that the dots remain constant in screen space.
          ctx.arc(x, y, dotSize / scale, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      /* Draw edges */
      ctx.strokeStyle = COLOR_SCHEME.EDGE;
      ctx.fillStyle = COLOR_SCHEME.EDGE;
      ctx.lineWidth = 2;
      for (const edge of edges) {
        const dx = edge.nodeB.x - edge.nodeA.x;
        const dy = edge.nodeB.y - edge.nodeA.y;
        const angle = Math.atan2(dy, dx);
        const startX = edge.nodeA.x + Math.cos(angle) * edge.nodeA.radius;
        const startY = edge.nodeA.y + Math.sin(angle) * edge.nodeA.radius;
        const endX = edge.nodeB.x - Math.cos(angle) * edge.nodeB.radius;
        const endY = edge.nodeB.y - Math.sin(angle) * edge.nodeB.radius;
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        const headLength = 15;
        const arrowAngle1 = angle + Math.PI / 7;
        const arrowAngle2 = angle - Math.PI / 7;
        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo(endX - headLength * Math.cos(arrowAngle1), endY - headLength * Math.sin(arrowAngle1));
        ctx.lineTo(endX - headLength * Math.cos(arrowAngle2), endY - headLength * Math.sin(arrowAngle2));
        ctx.closePath();
        ctx.fill();
      }
      
      /* Draw nodes */
      for (const node of nodes) {
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
        ctx.fillStyle = COLOR_SCHEME.NODE.FILL;
        ctx.fill();
        ctx.strokeStyle = COLOR_SCHEME.NODE.BORDER;
        ctx.lineWidth = 2;
        ctx.stroke();
        if (node.selected) {
          ctx.beginPath();
          ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
          ctx.strokeStyle = COLOR_SCHEME.NODE.SELECTED;
          ctx.lineWidth = 4;
          ctx.stroke();
        }
        if (node.text) {
          const maxTextWidth = node.radius * 2 * 0.8;
          const baseFontSize = 16;
          const { lines, fontSize } = wrapAndAdjustText(ctx, node.text, maxTextWidth, baseFontSize);
          ctx.font = `${fontSize}px sans-serif`;
          ctx.fillStyle = COLOR_SCHEME.NODE.TEXT;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          const lineHeight = fontSize * 1.2;
          const totalHeight = lines.length * lineHeight;
          let currentY = node.y - totalHeight / 2 + lineHeight / 2;
          for (const line of lines) {
            ctx.fillText(line, node.x, currentY);
            currentY += lineHeight;
          }
        }
      }
      
      /* Draw edge creation preview (if in connect mode) */
      if (isCreatingEdge && edgeStart) {
        const worldMouse = viewToWorld(mouseX, mouseY);
        const previewAngle = Math.atan2(worldMouse.y - edgeStart.y, worldMouse.x - edgeStart.x);
        const previewStartX = edgeStart.x + Math.cos(previewAngle) * edgeStart.radius;
        const previewStartY = edgeStart.y + Math.sin(previewAngle) * edgeStart.radius;
        ctx.beginPath();
        ctx.moveTo(previewStartX, previewStartY);
        ctx.lineTo(worldMouse.x, worldMouse.y);
        ctx.strokeStyle = COLOR_SCHEME.PREVIEW;
        ctx.lineWidth = 2;
        ctx.stroke();
        const headLength = 15;
        const arrowAngle1 = previewAngle + Math.PI / 7;
        const arrowAngle2 = previewAngle - Math.PI / 7;
        ctx.beginPath();
        ctx.moveTo(worldMouse.x, worldMouse.y);
        ctx.lineTo(worldMouse.x - headLength * Math.cos(arrowAngle1), worldMouse.y - headLength * Math.sin(arrowAngle1));
        ctx.lineTo(worldMouse.x - headLength * Math.cos(arrowAngle2), worldMouse.y - headLength * Math.sin(arrowAngle2));
        ctx.closePath();
        ctx.fillStyle = COLOR_SCHEME.PREVIEW;
        ctx.fill();
      }
      
      ctx.restore();
    }

    function animate() {
      update();
      draw();
      requestAnimationFrame(animate);
    }
    animate();

    /* Attach UI button event listeners */
    document.getElementById("add-node-btn").addEventListener("click", addNode);
    document.getElementById("delete-node-btn").addEventListener("click", deleteNode);
    document.getElementById("edit-node-btn").addEventListener("click", editNode);
    document.getElementById("connect-node-btn").addEventListener("click", startConnectMode);
    document.getElementById("cancel-connect-btn").addEventListener("click", cancelConnectMode);
    document.getElementById("export-mermaid-btn").addEventListener("click", () => {
      const mermaidString = getExportableMermaidGraph();
      downloadMermaid("graph.mmd", mermaidString);
    });
    document.getElementById("generate-roadmap-btn").addEventListener("click", generateRoadmap);
    document.getElementById("clear-graph-btn").addEventListener("click", () => {
      if (confirm("Are you sure you want to clear the graph? This will delete every node and its connections.")) {
        nodes.length = 0;
        edges.length = 0;
        clearSelection();
      }
    });

    /* Restore API Key from localStorage */
    const apiKeyInput = document.getElementById("openai-api-key");
    apiKeyInput.addEventListener("change", function(){
      localStorage.setItem("openaiApiKey", apiKeyInput.value);
    });
    const savedApiKey = localStorage.getItem("openaiApiKey");
    if(savedApiKey) {
      apiKeyInput.value = savedApiKey;
    }

    /* Stub functions for exporting and generating roadmaps */
    function getExportableMermaidGraph() {
      let mermaidString = "graph LR\n";
      let nodeToId = new Map();
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        const id = "node" + i;
        nodeToId.set(node, id);
        const safeText = node.text.replace(/"/g, '\\"');
        mermaidString += `${id}["${safeText}"]\n`;
      }
      for (const edge of edges) {
        const idA = nodeToId.get(edge.nodeA);
        const idB = nodeToId.get(edge.nodeB);
        if (idA !== undefined && idB !== undefined) {
          mermaidString += `${idA} --> ${idB}\n`;
        }
      }
      return mermaidString;
    }
    function downloadMermaid(filename, text) {
      const element = document.createElement("a");
      element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(text));
      element.setAttribute("download", filename);
      element.style.display = "none";
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
    async function generateRoadmap() {
      const userGoal = prompt("Enter your goal for the roadmap:");
      if (!userGoal) return;
      const currentMermaid = getExportableMermaidGraph();
      const promptMessage = generatePromptMessage(currentMermaid, userGoal);
      const responseData = await queryOpenAI(promptMessage);
      if (!responseData || !responseData.choices || responseData.choices.length === 0) {
        alert("Failed to get response from OpenAI.");
        return;
      }
      const reply = responseData.choices[0].message.content;
      console.log("Received mermaid diagram from OpenAI:", reply);
      nodes.length = 0;
      edges.length = 0;
      updateMermaidGraph(reply);
    }
    async function queryOpenAI(message) {
      const apiKey = document.getElementById("openai-api-key").value;
      if (!apiKey) {
        alert("Please enter your OpenAI API Key.");
        return;
      }
      const url = "https://api.openai.com/v1/chat/completions";
      const payload = {
        model: "gpt-4o",
        messages: [{ role: "user", content: message }],
        max_tokens: 150,
        temperature: 0.7
      };
      try {
        const response = await fetch(url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${apiKey}`
          },
          body: JSON.stringify(payload)
        });
        if (!response.ok) throw new Error(`Request failed with status ${response.status}`);
        const data = await response.json();
        console.log("OpenAI API Response:", data);
        return data;
      } catch (error) {
        console.error("Error querying OpenAI:", error);
      }
    }
    function updateMermaidGraph(mermaidText) {
      // Remove any markdown mermaid codeblocks
      mermaidText = mermaidText.replace(/```mermaid/g, "").replace(/```/g, "");
      // Split and trim lines, filtering out empty ones
      const lines = mermaidText.split('\n').map(line => line.trim()).filter(line => line !== '');
      
      // Remove the graph header if present (e.g. "graph LR")
      if (lines[0].startsWith("graph")) {
        lines.shift();
      }
      
      const newNodesMap = {};
      
      // Updated regex definitions:
      // Matches a standalone node: e.g., A[Some Label]
      const nodeRegex = /^(\w+)\s*\[\s*(.+?)\s*\]$/;
      // Matches node connections: e.g., A --> B
      const edgeRegex = /^(\w+)\s*-->\s*(\w+)$/;
      
      // Compute the center of the view in world coordinates.
      const centerWorld = viewToWorld(canvas.width / 2, canvas.height / 2);
      
      // First pass: Create all nodes
      lines.forEach(line => {
        let match = line.match(nodeRegex);
        if (match) {
          const nodeId = match[1];
          let nodeText = match[2];
          // If nodeText has quotes, remove them.
          nodeText = nodeText.replace(/['"]/g, "");

          if (!newNodesMap[nodeId]) {
            const offsetX = (Math.random() - 0.5) * 300;
            const offsetY = (Math.random() - 0.5) * 200;
            const newX = centerWorld.x + offsetX;
            const newY = centerWorld.y + offsetY;
            const newNode = new Node(newX, newY);
            newNode.text = nodeText;
            nodes.push(newNode);
            newNodesMap[nodeId] = newNode;
          }
        }
      });

      // Second pass: Create all edges
      lines.forEach(line => {
        let match = line.match(edgeRegex);
        if (match) {
          const sourceId = match[1];
          const targetId = match[2];
          
          // Only create edge if both nodes exist
          if (newNodesMap[sourceId] && newNodesMap[targetId]) {
            const sourceNode = newNodesMap[sourceId];
            const targetNode = newNodesMap[targetId];
            const dx = targetNode.x - sourceNode.x;
            const dy = targetNode.y - sourceNode.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            edges.push(new Edge(sourceNode, targetNode, length));
          }
        }
      });
    }

    // --- Zoom controls ---
    function updateZoomLabel() {
      document.getElementById("zoom-label").textContent = Math.round(scale * 100) + "%";
    }
    document.getElementById("zoom-in-btn").addEventListener("click", () => {
      const zoomFactor = 1.1;
      const center = { x: canvas.width / 2, y: canvas.height / 2 };
      const worldPos = viewToWorld(center.x, center.y);
      const newScale = scale * zoomFactor;
      panOffsetX = center.x - worldPos.x * newScale;
      panOffsetY = center.y - worldPos.y * newScale;
      scale = newScale;
      updateZoomLabel();
    });
    document.getElementById("zoom-out-btn").addEventListener("click", () => {
      const zoomFactor = 1.1;
      const center = { x: canvas.width / 2, y: canvas.height / 2 };
      const worldPos = viewToWorld(center.x, center.y);
      const newScale = scale / zoomFactor;
      panOffsetX = center.x - worldPos.x * newScale;
      panOffsetY = center.y - worldPos.y * newScale;
      scale = newScale;
      updateZoomLabel();
    });
    document.getElementById("zoom-reset-btn").addEventListener("click", () => {
      scale = 1;
      panOffsetX = 0;
      panOffsetY = 0;
      updateZoomLabel();
    });
    // --- End Zoom controls ---

    // Automatically load the saved mermaid data (if any) when the page loads.
    window.addEventListener('load', () => {
      loadMermaidData();
    });

    // Periodically update the mermaid data in localStorage to reflect the current nodes and edges.
    setInterval(() => {
      saveMermaidData();
    }, 1000);

    // Set up the instructions close button and load its closed state from localStorage
    document.addEventListener("DOMContentLoaded", function() {
      const instructionsElem = document.getElementById("instructions");
      const closeBtn = document.getElementById("instructions-close-btn");
      const showBtn = document.getElementById("show-instructions-btn");

      // Check localStorage for previous "closed" state:
      if (localStorage.getItem("instructionsClosed") === "true") {
        if (instructionsElem) {
          instructionsElem.style.display = "none";
        }
        if (showBtn) {
          showBtn.style.display = "block";
        }
      } else {
        if (instructionsElem) {
          instructionsElem.style.display = "block";
        }
        if (showBtn) {
          showBtn.style.display = "none";
        }
      }

      // Attach close event for the instructions panel.
      if (closeBtn) {
        closeBtn.addEventListener("click", () => {
          if (instructionsElem) {
            instructionsElem.style.display = "none";
          }
          if (showBtn) {
            showBtn.style.display = "block";
          }
          localStorage.setItem("instructionsClosed", "true");
        });
      }

      // Attach event for the show instructions button.
      if (showBtn) {
        showBtn.addEventListener("click", () => {
          if (instructionsElem) {
            instructionsElem.style.display = "block";
          }
          showBtn.style.display = "none";
          localStorage.setItem("instructionsClosed", "false");
        });
      }
    });
  </script>
</body>
</html>
